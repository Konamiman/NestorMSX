<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var lines = File.ReadAllLines(Host.ResolvePath("InstructionTemplatesSource.txt"));

var items =
	lines
	.Select(l => l.Trim().Replace("   ", " ").Replace("  ", " "))
	.Where(l => l != "" && !l.StartsWith(";"))
	.Select(l => { var tokens = l.Split(';').Select(t => t.Trim()).ToArray(); return tokens; })
	.Where(t => !t[1].StartsWith("CB") && !t[1].StartsWith("ED") && !t[1].StartsWith("DD") && !t[1].StartsWith("FD"))
	.Select(t => new Tuple<string, string[], byte[]>(t[0], t[1].Split(' '), t[1].Split(' ').Select(x => x=="DIS" || x.StartsWith("N") ? (byte)0 : Byte.Parse(x, System.Globalization.NumberStyles.AllowHexSpecifier )).ToArray()))
	.OrderBy(t => t.Item2[0])
	.ToArray()
	;

var nullTuple = new[] { new Tuple<string, string[], byte[]>(null, null, null)};

items = items
	.Take(0xCB)
	.Concat(nullTuple)
	.Concat(items.Skip(0xCB).Take(0xDD-0xCB-1))
	.Concat(nullTuple)
	.Concat(items.Skip(0xDD-1).Take(0xED-0xDD-1))
	.Concat(nullTuple)
	.Concat(items.Skip(0xED-2).Take(0xFD-0xED-1))
	.Concat(nullTuple)
	.Concat(items.Skip(0xFD-3).Take(0xFF-0xFD))
	.ToArray()
	;

var changingSp = new[] {"push", "pop", "call", "ret"};
var changingPc = new[] {"jp", "jr", "call", "ret", "djnz"};

int index = 0;
	#>
//AUTOGENERATED FILE - Do not modify directly
//Change the .tt file instead

namespace Konamiman.NestorMSX.Z80Debugger
{
    public partial class InstructionExtractor
    {
        private readonly Z80Instruction[] singleByteInstructionPrototypes =
        {
<# foreach(var item in items) { #>
<# if(item.Item1 == null) { #>
			null, //<#= string.Format("0x{0:X2}",index) #>
<# } else { #>
<# var formatString = item.Item1.Replace("NNo","{0}").Replace("NN","{0}").Replace("N","{0}"); #>
<#
	   var operandIndex = -1;
	   var bytes = item.Item2.ToList();

	   string operandType = "ImmediateByte";
	   operandIndex = bytes.IndexOf("N");
	   if(operandIndex == -1) {
		   operandType = "RelativeJumpAddress";
		   operandIndex = bytes.IndexOf("NNo");
       }
	   if(operandIndex == -1) {
		   operandType = "ImmediateWord";
		   operandIndex = bytes.IndexOf("NNl");
       }
	   if(operandIndex == -1) {
		   operandType = null;
       }

	   if(operandType == "ImmediateWord" && 
	       (item.Item1.Contains("(") || item.Item1.StartsWith("call") || item.Item1.StartsWith("jp")))
			operandType = "AbsoluteMemoryAddress";
#>
            new Z80Instruction //<#= string.Format("0x{0:X2}",index) #>
            {
                FormatString = "<#=formatString#>",
				RawBytes = new byte[] { <#= string.Join(", ", item.Item3.Select(b => string.Format("0x{0:X2}",b))) #> },
<# if(operandType == null) { #>
				Operands = new Operand[0],
<# } else { #>
				Operands = new[]
                {
                    new Operand
                    {
                        Type = OperandType.<#=operandType#>,
                        OffsetWithinInstruction = <#=operandIndex#>
                    }
                },
<# } #>
				InstructionType = InstructionType.Standard,
				ChangesSp = <#= changingSp.Any(x => item.Item1.StartsWith(x)) ? "true" : "false" #>,
                ChangesPc = <#= changingPc.Any(x => item.Item1.StartsWith(x)) ? "true" : "false" #>,
                WritesToMemory = <#= !item.Item1.StartsWith("ex") && !item.Item1.StartsWith("out") && item.Item1.Contains("),") ? "true" : "false" #>,
                WritesToPort = <#= item.Item1.StartsWith("out") ? "true" : "false" #>
            },
<# } index++;} #>
		};
    }
}