<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//AUTOGENERATED FILE - Do not modify directly
//Change the .tt file instead

using System.Collections.Generic;

namespace Konamiman.NestorMSX.Z80Debugger
{
    public partial class InstructionExtractor
    {
<#
foreach(var xy in new Tuple<byte, string, string>[] {new Tuple<byte, string, string>(0xDD, "DD", "ix"), new Tuple<byte, string, string>(0xFD, "FD", "iy")}) {

var prefix = xy.Item1;
var prefixString = xy.Item2;
var registerName = xy.Item3;

var lines = File.ReadAllLines(Host.ResolvePath("InstructionTemplatesSource.txt"));

var items =
	lines
	.Select(l => l.Trim().Replace("   ", " ").Replace("  ", " "))
	.Where(l => l != "" && !l.StartsWith(";"))
	.Select(l => { var tokens = l.Split(';').Select(t => t.Trim()).ToArray(); return tokens; })
	.Where(t => t[1].StartsWith(prefixString + " CB"))
	.Select(t => new Tuple<string, string[], byte[]>(t[0], t[1].Split(' '), t[1].Split(' ').Select(x => x=="DIS" || x.StartsWith("N") ? (byte)0 : Byte.Parse(x, System.Globalization.NumberStyles.AllowHexSpecifier )).ToArray()))
	.OrderBy(t => t.Item2[3])
	.ToDictionary(t => (byte)t.Item3[3], t => t)
	;

	var halfIndexRegisters = new[] {"ixh", "ixl", "iyh", "iyl"};

	#>
        private readonly Z80Instruction[] <#=prefixString#>CBInstructionPrototypes =
        {
<# for(int i = 0; i <= 0xFF; i++) { #>
<# 
	  var opcode = (byte)i;
	  Tuple<string, string[], byte[]> item;
	  string instructionType;
	  if(items.Keys.Contains(opcode)) {
		  item = items[opcode];
		  if((opcode & 7) == 6 && !item.Item1.StartsWith("sll")) {
			  instructionType = "Standard";
          } else {
			  instructionType = "Undocumented";
          }
      } else {
		  item = new Tuple<string, string[], byte[]>(
			  string.Format("bit {0},({1}+DIS)", ((opcode >> 3) & 3), registerName),
			  new[] {"DD","CB","DIS",string.Format("{0:X2}", opcode)},
			  new byte[] {0xDD, 0xCB, 0x00, opcode});
		  instructionType = "UnsafeMirror";
      }

      var formatString = item.Item1.Replace("NNo","{0}").Replace("NN","{0}").Replace("N","{0}").Replace("DIS","{0}");

	   var operandIndex = -1;
	   var bytes = item.Item2.ToList();

	   string operandType = "ImmediateByte";
	   operandIndex = bytes.IndexOf("N");
	   if(operandIndex == -1) {
		   operandType = "RelativeJumpAddress";
		   operandIndex = bytes.IndexOf("NNo");
       }
	   if(operandIndex == -1) {
		   operandType = "ImmediateWord";
		   operandIndex = bytes.IndexOf("NNl");
       }
	   if(operandIndex == -1) {
		   operandType = "IndexRegisterOffset";
		   operandIndex = bytes.IndexOf("DIS");
       }
	   if(operandIndex == -1) {
		   operandType = null;
       }

	   if(operandType == "ImmediateWord" && 
	       (item.Item1.Contains("(") || item.Item1.StartsWith("call") || item.Item1.StartsWith("jp")))
			operandType = "AbsoluteMemoryAddress";
#>
            new Z80Instruction //0x<#= prefixString#>, 0xCB, 0x00, <#= string.Format("0x{0:X2}",opcode)#>
            {
                FormatString = "<#=formatString#>",
				RawBytes = new byte[] { <#= string.Join(", ", item.Item3.Select(b => string.Format("0x{0:X2}",b))) #> },
<# if(operandType == null) { #>
				Operands = new Operand[0],
<# } else { #>
				Operands = new[]
                {
                    new Operand
                    {
                        Type = OperandType.<#=operandType#>,
                        OffsetWithinInstruction = <#=operandIndex#>
                    }
                },
<# } #>
				InstructionType = InstructionType.<#= instructionType #>,
				ChangesSp = false,
                ChangesPc = false,
                WritesToMemory = <#= formatString.StartsWith("bit") ? "false" : "true" #>,
                WritesToPort = false
			},
<# } #>
		};


<# } #>
    }
}