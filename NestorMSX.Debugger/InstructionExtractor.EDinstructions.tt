<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var lines = File.ReadAllLines(Host.ResolvePath("InstructionTemplatesSource.txt"));

var items =
	lines
	.Select(l => l.Trim().Replace("   ", " ").Replace("  ", " "))
	.Where(l => l != "" && !l.StartsWith(";"))
	.Select(l => { var tokens = l.Split(';').Select(t => t.Trim()).ToArray(); return tokens; })
	.Where(t => t[1].StartsWith("ED"))
	.Select(t => new Tuple<string, string[], byte[]>(t[0], t[1].Split(' '), t[1].Split(' ').Select(x => x=="DIS" || x.StartsWith("N") ? (byte)0 : Byte.Parse(x, System.Globalization.NumberStyles.AllowHexSpecifier )).ToArray()))
	.OrderBy(t => t.Item2[1])
	.ToDictionary(t => (byte)t.Item3[1], t => t)	;

var mirroredNegs = new byte[] { 0x4C, 0x54, 0x5C, 0x64, 0x6C, 0x74, 0x7C };
var mirroredRetis = new byte[] { 0x5D, 0x6D, 0x7D };
var mirroredRetns = new byte[] { 0x55, 0x65, 0x75 };
var mirroredIm0s = new byte[] { 0x4E, 0x66, 0x6E };
var undefineds = new byte[] { 0x77, 0x7F };
#>
//AUTOGENERATED FILE - Do not modify directly
//Change the .tt file instead

namespace Konamiman.NestorMSX.Z80Debugger
{
    public partial class InstructionExtractor
    {
        private readonly Z80Instruction[] EDInstructionPrototypes =
        {
<# for(byte opcode = 0x40; opcode < 0x80; opcode++) { #>
<# if(undefineds.Contains(opcode)) { #>
			null, //<#= string.Format("0x{0:X2}",opcode) #>
<# } else { #>
<#
	   Tuple<string, string[], byte[]> item;
	   string instructionType;

	   if(items.ContainsKey(opcode)) {
	       if(opcode == 0x70 || opcode == 0x71)
			   instructionType = "Undocumented";
		   else
			   instructionType = "Standard";

		   item = items[opcode];
       } else if(opcode == 0x63) {
		   instructionType = "SafeMirror";
		   item = new Tuple<string, string[], byte[]>(
			   "ld (NN),hl", 
			   new[] {"63", "NNl", "NNh"},
			   new byte[] {0x63, 0x00, 0x00});
	   } else if(opcode == 0x6B) {
		   instructionType = "SafeMirror";
		   item = new Tuple<string, string[], byte[]>(
			   "ld hl,(NN)", 
			   new[] {"6B", "NNl", "NNh"},
			   new byte[] {0x6B, 0x00, 0x00});
       } else {
		   instructionType = "UnsafeMirror";
		   string instructionName;
		   if(mirroredNegs.Contains(opcode))
			   instructionName = "neg";
		   else if(mirroredRetis.Contains(opcode))
			   instructionName = "reti";
		   else if(mirroredRetns.Contains(opcode))
			   instructionName = "retn";
		   else if(mirroredIm0s.Contains(opcode))
			   instructionName = "im 0";
		   else if(opcode == 0x76)
			   instructionName = "im 1";
		   else if(opcode == 0x7E)
			   instructionName = "im 2";
		   else
			   throw new InvalidOperationException(string.Format("unknown opcode byte: {0:X2}", opcode));

		   item = new Tuple<string, string[], byte[]>(
			   instructionName,
			   new[] { "ED", string.Format("{0:X2}", opcode) }, 
			   new byte[] { 0xED, opcode });
       }

	   var formatString = item.Item1.Replace("NNo","{0}").Replace("NN","{0}").Replace("N","{0}");

	   var operandIndex = -1;
	   var bytes = item.Item2.ToList();

	   if(formatString.StartsWith("rst"))
	       formatString = string.Format("rst {0:X}", int.Parse(formatString.Substring(4)));

	   string operandType = "ImmediateByte";
	   operandIndex = bytes.IndexOf("N");
	   if(operandIndex == -1) {
		   operandType = "RelativeJumpAddress";
		   operandIndex = bytes.IndexOf("NNo");
       }
	   if(operandIndex == -1) {
		   operandType = "ImmediateWord";
		   operandIndex = bytes.IndexOf("NNl");
       }
	   if(operandIndex == -1) {
		   operandType = null;
       }

	   if(operandType == "ImmediateWord" && 
	       (item.Item1.Contains("(") || item.Item1.StartsWith("call") || item.Item1.StartsWith("jp")))
			operandType = "AbsoluteMemoryAddress";
#>
            new Z80Instruction //<#= string.Format("0x{0:X2}",opcode) #>
            {
                FormatString = "<#=formatString#>",
				RawBytes = new byte[] { <#= string.Join(", ", item.Item3.Select(b => string.Format("0x{0:X2}",b))) #> },
<# if(operandType == null) { #>
				Operands = new Operand[0],
<# } else { #>
				Operands = new[]
                {
                    new Operand
                    {
                        Type = OperandType.<#=operandType#>,
                        OffsetWithinInstruction = <#=operandIndex#>
                    }
                },
<# } #>
				InstructionType = InstructionType.<#= instructionType#>,
				ChangesSp = <#= item.Item1.StartsWith("ld sp") ? "true" : "false" #>,
                ChangesPc = false,
                WritesToMemory = <#= item.Item1.StartsWith("ld (") ? "true" : "false" #>,
                WritesToPort = <#= item.Item1.StartsWith("out") ? "true" : "false" #>
            },
<# }} #>
		};

		private readonly Z80Instruction[] EDBlockInstructionPrototypes =
        {
<# for(byte opcode = 0xA0; opcode < 0xBC; opcode++) { #>
<# if(!items.Keys.Contains(opcode)) { #>
			null, //<#= string.Format("0x{0:X2}",opcode) #>
<# } else { #>
<# var item = items[opcode]; #>
            new Z80Instruction //<#= string.Format("0x{0:X2}",opcode) #>
            {
                FormatString = "<#=item.Item1#>",
				RawBytes = new byte[] { <#= string.Join(", ", item.Item3.Select(b => string.Format("0x{0:X2}",b))) #> },
				Operands = new Operand[0],
				InstructionType = InstructionType.Standard,
				ChangesSp = false,
                ChangesPc = false,
                WritesToMemory = <#= item.Item1.StartsWith("l") ? "true" : "false" #>,
                WritesToPort = <#= item.Item1.StartsWith("o") ? "true" : "false" #>
            },
<# }} #>
		};
    }
}